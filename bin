int i;
  int current_process = 1;
  int latest_process_available;

  int time_elapsed = bt[0];
  tat[0] = time_elapsed - at[0];
  wt[0] = tat[0] - bt[0];

  while(1) {
    latest_process_available = find_latest_process_available(at, n, time_elapsed, current_process);

    sort_by_burst_time(at, bt, current_process, latest_process_available);
    for(i=current_process; i<=latest_process_available; i++) {
      time_elapsed += bt[i];
      tat[i] = time_elapsed - at[i];
      wt[i] = tat[i] - bt[i];
    }
    current_process = i;

    if(current_process == n) break;
  }


  
void sort_by_burst_time(int *at, int *bt, int start_process, int end_process) {
  int i, j;
  for(i=start_process; i<=end_process; i++) {
    for(j=start_process; j<=end_process - i - 1; j++) {
      if(bt[j] > bt[j+1]) {
        bt[j] = bt[j] + bt[j+1];
        bt[j+1] = bt[j] - bt[j+1];
        bt[j] = bt[j] - bt[j+1];

        at[j] = at[j] + at[j+1];
        at[j+1] = at[j] - at[j+1];
        at[j] = at[j] - at[j+1];
      }
    }
  }
}

int find_latest_process_available(int *arrival_time, int n, int time_elapsed, int current_process) {
  int i;
  for(i=current_process; i<n; i++) {
    if(arrival_time[i] > time_elapsed) {
      return i-1;
    }
  }
  return n-1;
}